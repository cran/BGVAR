// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/BGVAR.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// BVAR_linear
List BVAR_linear(arma::mat Yraw, arma::mat Wraw, arma::mat Exraw, int plag, int draws, int burnin, int thin, bool cons, bool trend, bool sv, int prior, Rcpp::List hyperparam, Rcpp::List setting_store);
static SEXP _BGVAR_BVAR_linear_try(SEXP YrawSEXP, SEXP WrawSEXP, SEXP ExrawSEXP, SEXP plagSEXP, SEXP drawsSEXP, SEXP burninSEXP, SEXP thinSEXP, SEXP consSEXP, SEXP trendSEXP, SEXP svSEXP, SEXP priorSEXP, SEXP hyperparamSEXP, SEXP setting_storeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type Wraw(WrawSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type Exraw(ExrawSEXP);
    Rcpp::traits::input_parameter< int >::type plag(plagSEXP);
    Rcpp::traits::input_parameter< int >::type draws(drawsSEXP);
    Rcpp::traits::input_parameter< int >::type burnin(burninSEXP);
    Rcpp::traits::input_parameter< int >::type thin(thinSEXP);
    Rcpp::traits::input_parameter< bool >::type cons(consSEXP);
    Rcpp::traits::input_parameter< bool >::type trend(trendSEXP);
    Rcpp::traits::input_parameter< bool >::type sv(svSEXP);
    Rcpp::traits::input_parameter< int >::type prior(priorSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type hyperparam(hyperparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type setting_store(setting_storeSEXP);
    rcpp_result_gen = Rcpp::wrap(BVAR_linear(Yraw, Wraw, Exraw, plag, draws, burnin, thin, cons, trend, sv, prior, hyperparam, setting_store));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BGVAR_BVAR_linear(SEXP YrawSEXP, SEXP WrawSEXP, SEXP ExrawSEXP, SEXP plagSEXP, SEXP drawsSEXP, SEXP burninSEXP, SEXP thinSEXP, SEXP consSEXP, SEXP trendSEXP, SEXP svSEXP, SEXP priorSEXP, SEXP hyperparamSEXP, SEXP setting_storeSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BGVAR_BVAR_linear_try(YrawSEXP, WrawSEXP, ExrawSEXP, plagSEXP, drawsSEXP, burninSEXP, thinSEXP, consSEXP, trendSEXP, svSEXP, priorSEXP, hyperparamSEXP, setting_storeSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// do_rgig1
double do_rgig1(double lambda, double chi, double psi);
RcppExport SEXP _BGVAR_do_rgig1(SEXP lambdaSEXP, SEXP chiSEXP, SEXP psiSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< double >::type chi(chiSEXP);
    Rcpp::traits::input_parameter< double >::type psi(psiSEXP);
    rcpp_result_gen = Rcpp::wrap(do_rgig1(lambda, chi, psi));
    return rcpp_result_gen;
END_RCPP
}
// gvar_stacking
List gvar_stacking(const arma::mat xglobal, const int plag, const Rcpp::List globalpost, const int draws, const int thin, const bool trend, const bool eigen, const bool verbose);
RcppExport SEXP _BGVAR_gvar_stacking(SEXP xglobalSEXP, SEXP plagSEXP, SEXP globalpostSEXP, SEXP drawsSEXP, SEXP thinSEXP, SEXP trendSEXP, SEXP eigenSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type xglobal(xglobalSEXP);
    Rcpp::traits::input_parameter< const int >::type plag(plagSEXP);
    Rcpp::traits::input_parameter< const Rcpp::List >::type globalpost(globalpostSEXP);
    Rcpp::traits::input_parameter< const int >::type draws(drawsSEXP);
    Rcpp::traits::input_parameter< const int >::type thin(thinSEXP);
    Rcpp::traits::input_parameter< const bool >::type trend(trendSEXP);
    Rcpp::traits::input_parameter< const bool >::type eigen(eigenSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(gvar_stacking(xglobal, plag, globalpost, draws, thin, trend, eigen, verbose));
    return rcpp_result_gen;
END_RCPP
}
// globalLik
List globalLik(const SEXP Y_in, const SEXP X_in, const arma::cube A_in, const arma::cube S_in, const arma::cube Ginv_in, const SEXP thindraws_in);
RcppExport SEXP _BGVAR_globalLik(SEXP Y_inSEXP, SEXP X_inSEXP, SEXP A_inSEXP, SEXP S_inSEXP, SEXP Ginv_inSEXP, SEXP thindraws_inSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const SEXP >::type Y_in(Y_inSEXP);
    Rcpp::traits::input_parameter< const SEXP >::type X_in(X_inSEXP);
    Rcpp::traits::input_parameter< const arma::cube >::type A_in(A_inSEXP);
    Rcpp::traits::input_parameter< const arma::cube >::type S_in(S_inSEXP);
    Rcpp::traits::input_parameter< const arma::cube >::type Ginv_in(Ginv_inSEXP);
    Rcpp::traits::input_parameter< const SEXP >::type thindraws_in(thindraws_inSEXP);
    rcpp_result_gen = Rcpp::wrap(globalLik(Y_in, X_in, A_in, S_in, Ginv_in, thindraws_in));
    return rcpp_result_gen;
END_RCPP
}
// dmvnrm_arma_fast
arma::vec dmvnrm_arma_fast(const arma::mat& x, const arma::mat& mean, const arma::mat& sigma, bool const logd);
RcppExport SEXP _BGVAR_dmvnrm_arma_fast(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< bool const >::type logd(logdSEXP);
    rcpp_result_gen = Rcpp::wrap(dmvnrm_arma_fast(x, mean, sigma, logd));
    return rcpp_result_gen;
END_RCPP
}
// compute_irf
Rcpp::List compute_irf(arma::cube A_large, arma::cube S_large, arma::cube Ginv_large, const int type, const int nhor, const int thindraws, const SEXP shocklist_in, const bool verbose);
RcppExport SEXP _BGVAR_compute_irf(SEXP A_largeSEXP, SEXP S_largeSEXP, SEXP Ginv_largeSEXP, SEXP typeSEXP, SEXP nhorSEXP, SEXP thindrawsSEXP, SEXP shocklist_inSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::cube >::type A_large(A_largeSEXP);
    Rcpp::traits::input_parameter< arma::cube >::type S_large(S_largeSEXP);
    Rcpp::traits::input_parameter< arma::cube >::type Ginv_large(Ginv_largeSEXP);
    Rcpp::traits::input_parameter< const int >::type type(typeSEXP);
    Rcpp::traits::input_parameter< const int >::type nhor(nhorSEXP);
    Rcpp::traits::input_parameter< const int >::type thindraws(thindrawsSEXP);
    Rcpp::traits::input_parameter< const SEXP >::type shocklist_in(shocklist_inSEXP);
    Rcpp::traits::input_parameter< const bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_irf(A_large, S_large, Ginv_large, type, nhor, thindraws, shocklist_in, verbose));
    return rcpp_result_gen;
END_RCPP
}

// validate (ensure exported C++ functions exist before calling them)
static int _BGVAR_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("List(*BVAR_linear)(arma::mat,arma::mat,arma::mat,int,int,int,int,bool,bool,bool,int,Rcpp::List,Rcpp::List)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _BGVAR_RcppExport_registerCCallable() { 
    R_RegisterCCallable("BGVAR", "_BGVAR_BVAR_linear", (DL_FUNC)_BGVAR_BVAR_linear_try);
    R_RegisterCCallable("BGVAR", "_BGVAR_RcppExport_validate", (DL_FUNC)_BGVAR_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_BGVAR_BVAR_linear", (DL_FUNC) &_BGVAR_BVAR_linear, 13},
    {"_BGVAR_do_rgig1", (DL_FUNC) &_BGVAR_do_rgig1, 3},
    {"_BGVAR_gvar_stacking", (DL_FUNC) &_BGVAR_gvar_stacking, 8},
    {"_BGVAR_globalLik", (DL_FUNC) &_BGVAR_globalLik, 6},
    {"_BGVAR_dmvnrm_arma_fast", (DL_FUNC) &_BGVAR_dmvnrm_arma_fast, 4},
    {"_BGVAR_compute_irf", (DL_FUNC) &_BGVAR_compute_irf, 8},
    {"_BGVAR_RcppExport_registerCCallable", (DL_FUNC) &_BGVAR_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_BGVAR(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
